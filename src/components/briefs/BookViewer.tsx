'use client';

import { useState, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import type { Components } from 'react-markdown';

interface BookViewerProps {
  content: string;
  title: string;
  onClose: () => void;
}

export function BookViewer({ content, title, onClose }: BookViewerProps) {
  // Remove footer signature from content
  const cleanContent = content.replace(/---\s*\n\s*\*Generated by ORIGO[^*]*\*/g, '').trim();

  // Smart pagination: split by sections while respecting semantic blocks
  const pages = useMemo(() => smartPagination(cleanContent), [cleanContent]);
  const [currentPage, setCurrentPage] = useState(0);
  const [direction, setDirection] = useState(0);

  function nextPage() {
    if (currentPage < pages.length - 1) {
      setDirection(1);
      setCurrentPage(currentPage + 1);
    }
  }

  function prevPage() {
    if (currentPage > 0) {
      setDirection(-1);
      setCurrentPage(currentPage - 1);
    }
  }

  const variants = {
    enter: (direction: number) => ({
      x: direction > 0 ? 300 : -300,
      opacity: 0,
    }),
    center: {
      zIndex: 1,
      x: 0,
      opacity: 1,
    },
    exit: (direction: number) => ({
      zIndex: 0,
      x: direction < 0 ? 300 : -300,
      opacity: 0,
    }),
  };

  return (
    <div className="fixed inset-0 bg-base z-50 flex flex-col">
      {/* Header */}
      <div className="border-b border-edge px-6 py-4 flex items-center justify-between shrink-0">
        <div className="flex items-center gap-3">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className="text-accent">
            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20" />
            <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z" />
          </svg>
          <h2 className="text-lg font-semibold text-foreground">{title}</h2>
        </div>
        <button
          onClick={onClose}
          className="text-muted hover:text-foreground transition-colors p-2 min-h-[44px] min-w-[44px] flex items-center justify-center"
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <line x1="18" y1="6" x2="6" y2="18" />
            <line x1="6" y1="6" x2="18" y2="18" />
          </svg>
        </button>
      </div>

      {/* Book Pages */}
      <div className="flex-1 flex items-center justify-center p-4 md:p-8 overflow-hidden">
        <div className="relative w-full max-w-4xl h-full">
          <AnimatePresence initial={false} custom={direction} mode="wait">
            <motion.div
              key={currentPage}
              custom={direction}
              variants={variants}
              initial="enter"
              animate="center"
              exit="exit"
              transition={{
                x: { type: 'tween', duration: 0.2 },
                opacity: { duration: 0.15 },
              }}
              className="absolute inset-0 bg-surface rounded-lg shadow-2xl overflow-hidden"
            >
              {/* Page content with scroll */}
              <div className="h-full overflow-y-auto p-6 md:p-10 lg:p-12">
                <div className="book-content max-w-none">
                  <ReactMarkdown
                    remarkPlugins={[remarkGfm]}
                    components={customMarkdownComponents}
                  >
                    {pages[currentPage]}
                  </ReactMarkdown>
                </div>
              </div>

              {/* Page number */}
              <div className="absolute bottom-6 right-8 text-muted text-xs font-mono">
                {currentPage + 1} / {pages.length}
              </div>
            </motion.div>
          </AnimatePresence>
        </div>
      </div>

      {/* Navigation */}
      <div className="border-t border-edge px-6 py-4 flex items-center justify-between shrink-0">
        <button
          onClick={prevPage}
          disabled={currentPage === 0}
          className="flex items-center gap-2 text-foreground disabled:text-muted disabled:cursor-not-allowed hover:text-accent transition-colors px-4 py-2 min-h-[44px]"
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <polyline points="15 18 9 12 15 6" />
          </svg>
          <span className="hidden sm:inline">Previous</span>
        </button>

        <div className="flex items-center gap-2">
          <div className="flex gap-1">
            {pages.map((_, index) => (
              <button
                key={index}
                onClick={() => {
                  setDirection(index > currentPage ? 1 : -1);
                  setCurrentPage(index);
                }}
                className={`w-2 h-2 rounded-full transition-all ${
                  index === currentPage ? 'bg-accent w-6' : 'bg-edge hover:bg-accent/50'
                }`}
                aria-label={`Go to page ${index + 1}`}
              />
            ))}
          </div>
        </div>

        <button
          onClick={nextPage}
          disabled={currentPage === pages.length - 1}
          className="flex items-center gap-2 text-foreground disabled:text-muted disabled:cursor-not-allowed hover:text-accent transition-colors px-4 py-2 min-h-[44px]"
        >
          <span className="hidden sm:inline">Next</span>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <polyline points="9 18 15 12 9 6" />
          </svg>
        </button>
      </div>

      {/* Custom styles for book content */}
      <style jsx global>{`
        .book-content {
          font-family: -apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
          line-height: 1.7;
          color: var(--color-foreground);
        }

        .book-content h1 {
          font-size: 2rem;
          font-weight: 700;
          margin-top: 0;
          margin-bottom: 1.5rem;
          line-height: 1.2;
          color: var(--color-accent);
        }

        .book-content h2 {
          font-size: 1.5rem;
          font-weight: 600;
          margin-top: 2rem;
          margin-bottom: 1rem;
          line-height: 1.3;
          color: var(--color-foreground);
          border-bottom: 1px solid var(--color-edge);
          padding-bottom: 0.5rem;
        }

        .book-content h3 {
          font-size: 1.25rem;
          font-weight: 600;
          margin-top: 1.5rem;
          margin-bottom: 0.75rem;
          color: var(--color-foreground);
        }

        .book-content p {
          margin-bottom: 1rem;
          text-align: justify;
        }

        .book-content strong {
          font-weight: 600;
          color: var(--color-foreground);
        }

        .book-content em {
          font-style: italic;
        }

        .book-content ul, .book-content ol {
          margin: 1rem 0;
          padding-left: 2rem;
        }

        .book-content li {
          margin-bottom: 0.5rem;
        }

        .book-content a {
          color: var(--color-accent);
          text-decoration: underline;
          text-decoration-color: var(--color-accent);
          text-underline-offset: 2px;
        }

        .book-content a:hover {
          color: var(--color-accent-hover);
        }

        .book-content code {
          background: var(--color-surface);
          padding: 0.2em 0.4em;
          border-radius: 3px;
          font-size: 0.9em;
          font-family: ui-monospace, monospace;
          color: var(--color-accent);
        }

        .book-content pre {
          background: var(--color-surface);
          border: 1px solid var(--color-edge);
          border-radius: 6px;
          padding: 1rem;
          margin: 1rem 0;
          overflow-x: auto;
        }

        .book-content pre code {
          background: none;
          padding: 0;
          color: var(--color-foreground);
        }

        .book-content blockquote {
          border-left: 4px solid var(--color-accent);
          padding-left: 1rem;
          margin: 1rem 0;
          font-style: italic;
          color: var(--color-muted);
        }

        .book-content hr {
          border: none;
          border-top: 1px solid var(--color-edge);
          margin: 2rem 0;
        }

        .book-content table {
          width: 100%;
          border-collapse: collapse;
          margin: 1.5rem 0;
          font-size: 0.95em;
        }

        .book-content thead {
          background: var(--color-surface);
          border-bottom: 2px solid var(--color-edge);
        }

        .book-content th {
          padding: 0.75rem;
          text-align: left;
          font-weight: 600;
          color: var(--color-foreground);
        }

        .book-content td {
          padding: 0.75rem;
          border-bottom: 1px solid var(--color-edge);
        }

        .book-content tbody tr:hover {
          background: var(--color-surface);
        }

        /* Task lists */
        .book-content input[type="checkbox"] {
          margin-right: 0.5rem;
          accent-color: var(--color-accent);
          cursor: pointer;
        }

        .book-content li:has(input[type="checkbox"]) {
          list-style: none;
          margin-left: -2rem;
          padding-left: 2rem;
        }
      `}</style>
    </div>
  );
}

// Custom markdown components for better rendering
const customMarkdownComponents: Components = {
  h1: ({ children }) => (
    <h1 className="text-accent">{children}</h1>
  ),
  h2: ({ children }) => (
    <h2>{children}</h2>
  ),
  h3: ({ children }) => (
    <h3>{children}</h3>
  ),
  table: ({ children }) => (
    <div className="overflow-x-auto">
      <table>{children}</table>
    </div>
  ),
  // Custom rendering for checkboxes in task lists
  input: (props) => {
    if (props.type === 'checkbox') {
      return <input {...props} disabled={false} />;
    }
    return <input {...props} />;
  },
};

// Smart pagination algorithm
function smartPagination(content: string): string[] {
  const MIN_PAGE_LENGTH = 400; // Minimum chars per page
  const TARGET_PAGE_LENGTH = 1200; // Target chars per page
  const MAX_PAGE_LENGTH = 2000; // Maximum chars per page

  // Split by H2 sections first (semantic blocks)
  const sections = content.split(/(?=^## )/gm).filter(s => s.trim());

  const pages: string[] = [];
  let currentPage = '';

  for (const section of sections) {
    const sectionLength = section.length;

    // If current page + section exceeds max, push current page
    if (currentPage && (currentPage.length + sectionLength > MAX_PAGE_LENGTH)) {
      // Only push if current page has minimum content
      if (currentPage.length >= MIN_PAGE_LENGTH) {
        pages.push(currentPage.trim());
        currentPage = section;
      } else {
        // Current page too short, append section anyway
        currentPage += '\n\n' + section;
      }
    } 
    // If section alone is too long, split it by paragraphs
    else if (sectionLength > MAX_PAGE_LENGTH) {
      if (currentPage) {
        pages.push(currentPage.trim());
        currentPage = '';
      }

      // Split long section by paragraphs
      const paragraphs = section.split(/\n\n+/);
      let tempPage = '';

      for (const para of paragraphs) {
        if (tempPage && (tempPage.length + para.length > TARGET_PAGE_LENGTH)) {
          pages.push(tempPage.trim());
          tempPage = para;
        } else {
          tempPage += (tempPage ? '\n\n' : '') + para;
        }
      }

      if (tempPage) {
        currentPage = tempPage;
      }
    }
    // Normal case: append to current page
    else {
      currentPage += (currentPage ? '\n\n' : '') + section;

      // If current page reaches target length, push it
      if (currentPage.length >= TARGET_PAGE_LENGTH) {
        pages.push(currentPage.trim());
        currentPage = '';
      }
    }
  }

  // Push remaining content
  if (currentPage.trim()) {
    // If last page is too short, merge with previous
    if (pages.length > 0 && currentPage.length < MIN_PAGE_LENGTH) {
      pages[pages.length - 1] += '\n\n' + currentPage;
    } else {
      pages.push(currentPage.trim());
    }
  }

  // Fallback: if no pages generated, return full content
  return pages.length > 0 ? pages : [content];
}
